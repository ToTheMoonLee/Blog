## JVM相关

### 内存模型

![Java内存模型](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/runtime_data_region.jpg)

##### 程序计数器

1. 一块较小的内存空间，可以看错当前线程所执行的字节码的指令行号指示器。
2. 与CPU中的PC寄存器功能类似，可以实现循环、分支跳转、异常、线程恢复等功能。
3. 为了实现多线程时线程切换，就需要使用程序计数器来记录当前线程执行到的字节码的位置，这部分内存是线程私有的。
4. 如果当前执行的是Java方法，则保存的就是虚拟机字节码指令的地址；而如果执行的是Native方法，则值为空。

##### 虚拟机栈

1. 线程私有的。生命周期与线程相同。
2. 描述的是Java方法执行的线程内存模型，每个方法执行的时候都会创建一个Stack Frame（栈帧），用于保存**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。
3. 每个方法从执行到结束都对应一个栈帧在虚拟机中入栈到出栈的过程。
4. 局部变量表中保存了基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（可以是指向一个对象的起始地址、也可以是代表一个对象的句柄）、returnAddress（指向一条字节码的指令的地址）。
5. 存储空间以Slot（槽）来表示，64位长度的long、double占两个Slot，其余的占1个Slot。一个Slot具体多大，不同的JVM实现不同，有的是32位，有的是64位。

##### 本地方法栈

线程私有的，与虚拟机栈发挥的功能类似，区别就是本地方法栈执行的是Native方法。

##### Java堆

1. 线程共享的，是虚拟机所管理的内存中最大的一块。在虚拟机启动时创建。
2. 虚拟机规范对其描述为：所有的对象实例及数组都应该在堆上分配
3. 是垃圾收集器管理的内存区域。为了更好更快的回收和分配内存，往往会将其进行分代处理，分为Eden、新生代、老生代、survivor等等，但是只是一种分代风格，并不是规范。
4. 从分配内存的角度，可以划分出线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）
5. 内存在物理上可以连续分配，也可以不连续分配

##### 方法区

1. 线程共享的。存储已经被虚拟机加载的**类型信息**、**常量**、**静态变量**、**即时编译器编译后的代码缓存**。
2. 可以连续分配内存，也可以不连续分配。
3. 虚拟机规范没有要求实现垃圾回收。

##### 运行时常量池

1. Runtime Constant Pool是方法区的一部分。Class文件除了版本、字段、方法、接口等描述信息外，还有一项是常量池表（Constant Pool Table），这部分将在Class加载后存放到Runtime Constant Pool
2. 不一定编译时就产生，运行时也可以将新的常量放入池中

##### 直接内存

典型的就是NIO（New Input/Output），可以使用Native函数库直接分配堆外的内存。见2.2.7

### 对象创建

##### 对象创建

1. 碰到new关键字时，先检查指令参数在常量池中是否能找到一个类的符号引用，并检查这个类是否已经加载、解析和初始化。如果没有，则需要先加载类。
2. 为新生对象分配内存。根据垃圾回收器是否有Compact（压缩）功能，可以分为两种方式：第一种是未分配的内存和已分配的内存分别在两边，这个时候，只需要以一个指针为分界，偏移该指针即可（类所占的内存大小，在类加载完成后就已经确定了）；第二种是非连续的，那么就需要一个free list（空闲表）来记录内存的分配情况。
3. 关于解决多线程分配内存冲突问题，采用两种方式解决：第一种，进行同步处理，使用的是CAS失败重试，保证分配内存是一个原子操作；第二种，使用Thread Local Allocation Buffer（线程本地分配缓冲），现在各个线程的私有内存分配，超出部分再使用同步。
4. 将分配的内存初始化为0值。
5. 进行一些必要的设置，如这个对象是哪个类的实例、对象Hash、对象分代年龄等，这些信息都保存在对象头中。

##### 对象布局

1. 分为三部分：Header（对象头）、Instance Data（对象数据）、Padding（对象填充）
2. Header，对象头中的信息分为两部分：第一部分，一些自身运行时的信息：包括Hash、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分称为Mark Word，一般为32bit或者64bit；第二部分，类型指针，指向了他的类型元数据，用来确定该对象属于哪个实例，如果是数组的话，还会保存数组的长度。
3. Instance Data对象实例信息：我们在程序代码中真正定义的数据，无论是从父类继承的还是自己的，都会在这部分
4. Padding对象填充：用来对齐填充为8的整数倍

##### 对象的访问

![handle_access](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/handle_access.jpg)

![pointer_access](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/pointer_access.jpg)

1. 实现对象访问就是要使用栈上的局部变量表里的refrence来操作具体的对象，具体的方式有两种：第一种，使用句柄的方式访问；第二种，使用直接指针的方式来访问。具体见上图。
2. 两种方式各有优势：句柄方式在对象移动时，只需要改变句柄池中的引用地址；而直接指针的方式不需要二次指针定位的开销

### 垃圾回收器和内存分配策略

> 由于程序计数器、虚拟机栈、本地方法栈是线程私有的，随着线程的创建而创建，随着线程的消亡而消亡，而且虚拟机栈中的栈帧随着方法的开始和结束进而进行入栈和出栈的操作。并且每个栈帧具体占多少内存也基本在类结构确定的时候就定好了，所以这三部分不需要过多考虑如何回收问题。
> 而Java堆和方法区则不同，他们具体会创建多少个对象是在运行时需要确定的，所以这里是垃圾回收器重点关注的位置

##### 引用计数法

实现：给每个对象分配一个引用计数器，每当有一个地方引用它，计数器就+1，引用失效时，计数器就-1。计数器为0则表示对象不再被使用了。

这种算法虽然简单，但是Java垃圾回收器并没有采用这种算法。因为它没办法检测出互相引用的情况，比如A对象的一个变量指向B对象，而B对象的一个引用指向了A对象。

##### 可达性分析（Reachability Analysis）

Java中使用的算法。所谓可达性分析，就是从一系列称为“GC Roots”的根节点作为起始点，从这些节点开始向下搜索，搜索走过的路程叫做引用链（Reference Chain），如果某个对象没有任何引用链与其相连，则表示该对象不再被使用。如图：

![Reachability](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/reachability_analysis.jpg)

可以作为GC Roots的对象有：
1. **在虚拟机栈帧中引用的对象**：方法栈帧中使用到的参数、局部变量、临时变量等
2. **方法区中静态属性引用的对象**：Java引用类型静态变量
3. **Java方法区中常量引用的对象**：字符串常量池中引用的对象
4. **本地方法栈中JNI引用的对象**
5. **被同步锁（Synchronized）持有的对象**

##### 引用类型

1. **强引用**：Java中最普遍的引用方式，比如Object o = new Object()，就是强引用，只要强引用指向的对象可达，就不会被回收。
2. **软引用**：描述一些非必须的对象，使用SoftReference类来实现软引用。当内存发生溢出之前，会对其进行回收，如果回收后还是内存不足，则抛出OOM
3. **弱引用**：描述一些更弱的非必须的对象，使用WeakRefrence类来实现弱引用。在GC开始工作时，就会将其回收。
4. **虚引用**：最弱的一种引用关系，无法通过虚引用获取对象，使用PhantomReference实现，唯一的目的就是在GC工作时收到一个系统通知

##### 不可达对象回收与否

即使一个对象在可达性分析中被判定为不可达，那么它也不一定被立即回收，而是会至少经过两次标记的过程：第一次被认定不可达时，它会被进行第一次标记，随后进行一次筛选，筛选条件就是看其是否需要执行finilize()方法，如果对象没有重写finilize()方法或者finilize()已经调用过一次，那么就会被认定不需要调用finilize()方法。
如果判定为需要调用finilize()方法，那么该对象会被放到一个F-Queue的队列里，并稍后由一个低优先级的Finilizer线程去执行它们的finilize()方法，但是并不保证一定执行结束。如果在finilize()中将自己的this与引用链建立关系，则该对象就不会被回收了。
但是，不推荐使用finilize()方法！

### 垃圾收集算法

##### 分代理论

大多数虚拟机都是基于“分代理论“去设计的，一般都会遵循如下三个假说：
1. 弱分代假说（Weak Generational Hypothesis)：绝大多数对象朝生夕灭
2. 强分代假说（Strong Generational Hypothesis）：如果多次垃圾回收该对象都没死，则该对象难以消亡
3. 跨代引用假说（InterGenerational Reference Hypothsis）：young generation和old generation可能会相互引用

大多数遵循其原则：将Java堆划分成不同的区域，然后根据对象的年龄将其分配到不同的区域，如果一个区域都是容易被回收的对象，那么每次回收就只需要关注如何保留少量存活的对象。而如果一个区域是那些存活时间比较长的对象，则低频率来回收这个区域即可。
这样对于不同的区域使用不同的垃圾收集算法，就可以提高垃圾回收的效率。

##### 垃圾回收算法

* **标记-清除算法（Mark Sweep）**：分为标记和清除两个阶段，可以标记需要回收的对象，统一清除被标记的对象。也可以反过来，标记不需要回收的对象，统一清除未被标记的对象。
  优点：实现简单
  缺点：1. 效率不稳定，随着对象的增长效率下降；2. 会产生内存碎片
  
  ![mark_sweep](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/mark_sweep.jpg)
  
* **标记-复制算法（Semispace copying）**：最简单的实现是将内存区域分平均分为两块，当其中一块用完之后，将还存活的对象复制到另一块上，同时将当前这块内存清除。
  优点：实现简单，内存连续
  缺点：浪费了一半内存
  
  ![semispace_copying](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/semispace_copying.jpg)
  
  改进型的实现：将内存按照8:1:1的比例分为Eden区和两个suvivoer区，最初时使用Eden和其中一个Suvivor区，当启用垃圾收集时，将存活的对象复制到另一个Suvivor区，然后直接清掉Eden和当前的suvivor区。当然如果存活的对象大小超过了一个suvivor区的大小，就会启动Handle Promotion分配担保机制，一般会直接将其分配到Old Generation。
  
* **标记-整理算法（Mark Compact）**：首先第一步还是标记，第二步将不需要回收的对象统一移动到内存空间的一端，将边界之后的内存清除。
  优点：内存连续
  缺点：移动时需要暂停用户应用
  
  ![mark_compact](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/mark_compact.jpg)
  
### 类文件结构

##### 无关性

JVM即是平台无关也，也是语言无关的，无论是x86还是arm架构的平台，无论是java语言、kotlin语言还是其他语言，只要最终给JVM有效的Class文件，就能在这些平台上执行

![jvm_class_code](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/jvm_class_code.jpg)

##### Class类文件结构

1. Class类文件是定义好的一系列二进制数字，以8个字节为单位的二进制流，严格按照规定的顺序排列在文件中，中间是没有分隔符的。
2. 类似C语言的伪结构，分为两种类型，“无符号数”和“表”。**无符号数**：是基本数据类型，以u1，u2，u4，u8来代表1，2，4，8个字节，无符号数可以描述**数值**、**索引引用**、**数量值**、**UTF-8构成的字符串**。**表**：是由多个无符号数和其他表构成的复合数据类型。为了便于区分，所有表的命名都习惯性的以“_info“结尾。
3. 当描述同一类型的单数数量不定时的多个数据时，通常会前置一个容量计数器加若干个连续的数据项的形式，具体见下图。
4. “Class文件格式”不一定要以文件的形式存在
5. Class Code中，各个数据项无论是类型，长度，顺序，大小都是严格定义好的，见下图。

![class_code_table](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/class_code_table.jpg)

![class_code_image](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/class_code_image.jpg)

##### magic number和版本

magic number：占用前四个字节，内容固定为CAFEBABE，用来标志文件格式。很多其他的文件格式也经常使用magic number来识别格式。
版本号：5，6个字节为minor version，7，8个字节为major version

##### 常量池（Constant Pool）

1. 被喻为是Class文件里的资源仓库，是文件结构与其他项目关联最多的数据，是占用Class文件空间最大的数据项目之一
2. 常量池入口处是一个为u2类型的数据，用于描述常量池的计数值。索引是从**1**开始计数的，**0**保留为表示不引用常量池中的任何字段
3. 常量池中主要存放两大类常量：字面量（Literal）、符号引用（Symbolic References）
4. Literal（字面量）：接近Java语言层面的常量概念，比如字符串、被声明为final的常量等。Symbolic References（符号引用）：Java在编译时没有动态链接的过程，也就是说，Class文件不会保存各个方法、字段在内存中的布局信息。所以需要经过将符号引用在运行期转换之后才能拿到真正的内存入口地址。Symbolic References（符号引用）主要包括几个常量：被模块导出或开放的包（Package）、类和接口的全限定名（Full Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符、方法句柄和方法类型（Method Handle、Method Type）、动态调用点和动态常量（Dynamically-Computed Call Cite）
5. 常量池中每一项常量都是一个表，具体的各个常量的标志如下图
6. 每一项常量类型都是完全独立的，各自有自己的结构。比如，某个类的常量池中，第一项标识位为0x07，那么代表这是一个`CONSTANT_Class_info`类型的，而此类型代表一个类或者接口的符号引用，它的结构为u1类型的tag，之后为u2类型的index。u1类型的tag即如0x07代表这是一个`CONSTANT_Class_info`类型，而u2类型的index指向的是常量池中的一个`CONSTANT_Utf8_info`类型的常量，如0x0002（4个16进制代表两个字节），代表指向常量池中的第2个常量。其他的常量也有类似的规定。
7. 可以使用`javap -verbose HelloJVM` （HelloJVM为编译的class文件名）
8. 一些譬如“I”、“V”、“<init>”等字符串常量，是编译器自动生成的，用来表示方法的返回值，字段类型等等信息

![constant_table_type](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/constant_table_type.jpg)

![constant_class_info](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/constant_class_info.jpg)

![constant_table_1](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/constant_table_1.jpg)

![constant_table_2](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/constant_table_2.jpg)

![constant_table_3](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/constant_table_3.jpg)

##### 访问标志

1. 常量池之后的2个字节，表示访问标志。包括这个Class是类还是接口、是否是public类型、是否定义为abstract、是否是final等等
2. 16个bit位，每个位置可以代表一种状态，现在只定义了9种，可以通过`|`的方式，来形成最终的值

![access_flag](/Users/lixiangyue/Personal/blog/Blog/JVM/access_flag.jpg)

##### 类索引、父类索引和接口索引集合

1. 访问标志之后一次是类索引、父类索引、接口索引。都是u2类型的，这个u2类型的值指向了常量池中的一个`CONSTANT_Class_Info`类型的表，进而定位到全限定名。
2. 这三个索引的值，可以确定继承关系。其中类索引、父类索引各1个，而接口索引为多个，接口索引的入口第一项是u2类型的数据，表示之后有多少个接口。如果没有实现任何接口则该项为0。（比如从类索引开始值依次为 0x0001、0x0003、0x0000，则表示类索引指向常量池中的第一个位置，父类索引指向常量池中的第3个位置，接口索引个数为0）

##### 字段表集合

1. 类索引等之后是字段表集合。用于描述接口或类中声明的变量。包括access_flags、name_index、descriptor_index、attributes_count、attributes
2. access_flags包括作用于（private、public、protected）、是否final、是否static、并发可见性（volatile）等
3. name_index指向常量池中的一个`CONSTANT_Utf8_info`值，表示字段的名字
4. `descriptor_index`指向常量池中`CONSTANT_Utf8_info`，表示类型
5. JVM中使用大写字母来表示一些基本类型，B--byte,C--char,D--double,F--float,I--int,J--long,S--short,Z--boolean,V--void,L--对象类型（比如Ljava/lang/Object)
6. 数组表示比如 int[][] 则表示法为 [[I
7. 方法表示，比如 `int indexOf(char[] source, int sourceOffset, int sourceCount,char[] target, int targetOffset, int targetCount,int fromIndex)`则可以表示为 ([CII[CIII)I
8. attributes会存放一些额外信息，比如`final static int m = 123`，则attributes可能会存在一项ConstantValue属性，指向常量123

![field_info](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/field_info.jpg)

![desciptor_info](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/desciptor_info.jpg)

##### 方法表集合

1. 字段表集合之后是方法表集合，用于描述接口或类中的方法。包括access_flags、name_index、descriptor_index、attributes_count、attributes。各字段含义与字段表中的含义基本一致。
2. 方法中的代码被放到了attributes表中的一个名为Code的属性里

![method_info](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/method_info.jpg)

##### 属性表

1. Class文件、字段表、方法表都可以有自己的属性表集合。用于描述某些场景专有的信息。
2. 属性表要求不太严格，任何JVM厂商都可以写入自定义的属性，而且顺序也不做严格要求。详细信息见《深入理解Java虚拟机》属性表集合

### 字节码指令简介

##### 字节码指令简介

1. JVM的指令是由一个字节长度、代表某种操作含义的数字（Opcode操作吗）以及跟随其后的0个或多个所需参数（Operand操作数）构成。
2. JVM操作吗长度为1个字节，即0～255，现在JVM总指令数为201个
3. 执行模型可以简单概括为pc存着当前字节流中要取出的操作码，然后每取出一个字节，PC自动+1

##### 字节码与数据类型

1. 大多数字节码都包含了操作对应数据的类型，比如iload表示从局部变量表中加载int类型的数据到操作数栈
2. 大部分指令都没有支持byte、char、short，没有指令支持boolean，在执行byte和short时，会进行有符号拓展为int，boolean和char则为进行无符号拓展为int

根据字节码操作的用途，大致可以分为9类，具体如下

##### 1. 加载和存储指令

1. 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
2. 这类指令包括，**1. 将一个局部变量加载到操作栈**：`Xload、Xload_<n>`；**2. 将一个数值从操作数栈存储到局部变量表**：`Xstore、Xstore_<n>`; **3. 将一个常量加载到操作数栈**：`bipush、sipush、ldc等等`。（X可以替换为i、d等具体类型；<n>表示是一类指令，比如iload_0、iload_1等，直接显式的写出操作数）

##### 2. 运算指令

1. 用于对两个操作数栈上的值进行某种特定的运算，主要分为整型和浮点型数据运算两种。
2. 包括**1. 加法指令：Xadd**、**2. 减法指令：Xsub**、**3. 乘法指令：Xmul**、**4. 除法指令：Xdiv**、**5. 求余指令：Xrem**、**6. 取反指令：Xneg**、**7. 位移指令：Xshl、Xshr**、**8. 按位或指令：Xor**、**9. 按位与指令：Xand**、**10. 按位异或指令：Xxor**、**11. 局部变量自增指令：iinc**、**12. 比较指令：Xcmpg、Xcmpl**（以上指令中X可替换为i、l、f等）

##### 3. 类型转换指令

1. 用于将两种不同的数值类型相互转换，一般用于显示类型转换
2. 包括：i2b、i2c、i2s、l2i等等

##### 4. 对象创建于访问指令

1. 用来实例化对象和访问
2. 包括**1. 创建类实例的指令：new**、**2. 创建数组的指令：newarray、anewarray、multianewarray**、**3. 访问类字段和实例的字段：getfield、putfield、getstatic、putstatic**、**4. 把一个数组元素加载到操作数栈：Xaload**、**5.将操作数栈的值存到数组元素中：Xastore**、**6. 取数组长度：arraylength**、**7. 检查类实例类型：instanceof、checkcast**

##### 5. 操作数栈管理指令

1. 直接操作操作数栈的指令
2. 包括**1. 将操作数栈顶一个或两个元素出栈：pop、pop2**、**2. 复制栈顶一个或两个元素或双份的复制重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2**、**将栈顶端两个数值互换：swap**

##### 6. 控制转移指令

1. 可以让Java虚拟机有条件或无条件的从指定位置的下一条指令继续执行。实质上就是在修改PC寄存器的值。
2. 包括**1. 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、ificmpeq等等**、**2. 复合条件分支：tablesswitch、lookupswitch**、**3. 无条件分支：goto、goto_w、jsr、jsr_w、ret**

##### 7. 方法调用和返回指令

1. 方法调用指令包括**1. invokevirtual指令：用于调用对象的实例方法，最常见的方法分派方式。**、**2. invokeinterface指令：调用接口方法，搜索一个实现了这个接口方法的对象，找出适合的方法调用。**、**3. invokespecial指令：用于调用一些特殊的实例方法，如初始化方法、私有方法、父类方法。**、**4. invokestatic指令：用于调用静态方法。**、**5. invokedynamic指令：没太明白**
2. 方法返回指令包括**1. ireturn（返回值是boolean、byte、short、char、int时使用）**、**2. lreturn**、**3. freturn**、**4. dreturn**、**5. areturn**、**6. return指令提供声明为void的方法、实例初始化方法、类和接口初始化方法使用**

##### 8. 异常处理指令

1. 使用**athrow指令来实现Java程序中的throw语句
2. 处理异常使用的是异常表来完成的

##### 9. 同步指令

1. JVM支持方法级的同步和方法内部的一段指令序列的同步。方法级同步不需要字节码指令控制，而是要在方法表接口中，查看ACC_SYNCHRONIZED访问标志，查看其是否设置为同步方法，进而在方法调用时，使用锁机制保证同步
2. 一段指令序列的同步在Java中使用synchronized关键字实现，在字节码中使用monitorenter和monitorexit两条指令来支持。会生成对应的异常处理表，保证一定会有对应的monitorexit指令。

### 公有设计，私有实现

1. JVM的实现，只要在满足《Java虚拟机规范》的约束下对其具体实现作出修改和优化时完全可行的。
2. 主要的实现方式有以下两种：1. 将输入Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集；2. 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即时编译器代码生成技术）

### 虚拟机类加载

##### 虚拟机类加载机制

1. JVM把描述类的数据从Class文件加载到内存，并进行数据校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程则为虚拟机类加载机制。
2. Java中的类型加载、链接和初始化的过程是在程序运行的期间完成的，这会让Java在提前编译时面临额外的困难，但是也会提高其灵活性。可以让本地程序在运行时，在其他任何地方加载一个二进制流作为其程序代码的一部分（比如网络中）

##### 类加载时机

1. 一个类型从被加载到虚拟机内存开始，到卸载出内存为止，将会经历Loading（加载）、Verification（验证）、Preparation（准备）、Resolution（解析）、Initiation（初始化）、Using（使用）、Unload（卸载）七个阶段。
2. 《Java虚拟机规范》规定，有且只有六中情况必须对类进行“初始化”，分别为：**1. 遇到new、getstaic、putstatic、invokestatic指令，如果没有进行类型初始化，则必须先初始化（new关键字、读取或设置静态字段、调用一个静态方法均会触发）；2. 对类型进行反射调用时；3. 初始化类时；4. 虚拟机启动时，需要指定一个要执行的主类（包含main()方法的类）； 5. JDK7新加入的动态语言支持； 6. 接口中定义了JDK8新加入的默认方法**

### 类加载过程

##### Loading 加载

1. 加载阶段主要完成如下几件事：**1. 通过一个类的全限定名来获取此类的二进制字节流；2. 将这个字节流所代表的静态存储结构转化为方法区运行时的数据结构； 3. 在内存中生成一个代表这个类的java.lang.Class对象，作为访问这个类的各种数据的访问入口**
2. 《Java虚拟机规范》对这三点要求并不是很具体，尤其是第一条，通过全限定名来获取类的二机制字节流，因此，其实可以通过各种方式来获取这个字节流，比如：从ZIP压缩包中读取、从网络获取、运行时计算生成，典型的场景就是动态代理，Proxy类、由其他文件生成、数据库读取、加密文件读取等等
3. 类加载过程既可以用JVM内置的引导类加载器完成，也可以用户自定义类加载器完成（重新ClassLoader的findClass()和loadClass()）

##### Verification 验证

1. 这个阶段是连接的第一步，目的是确保Class文件字节流包含的信息符合《Java虚拟机规范》的全部约束要求，保证整体系统的安全。
2. 主要包括如下四个阶段的检验动作：**1. 文件格式验证，验证是否符合Class文件格式：如是否以魔数CAFEBABE开头、主次版本号是否在接受范围、常量池中是否有不被支持的常量、常量池中的索引是否指向不存在的常量、Utf8类型是否符合规范等；2. 元数据验证，主要是对字节码描述信息进行语义分析：如这个类是否有父类（Object除外）、这个类的父类是否是不可继承的、这个类不是抽象类时，是否实现了其父类或接口的要求实现的方法等等； 3. 字节码验证，通过数据流和控制流分析程序语义的合法性：如保证任何时刻操作数栈的数据类型和指令代码序列能配合工作（如操作数栈放置了一个int，使用时却按long来加载）、跳转指令是否跳到方法提以外、保证类型转换总是有效等等； 4. 符号引用验证，主要用来看作对类自身以外的各类信息进行匹配性校验：如符号引用中通过字符串描述的全限定名是否能找到对应的类、指定类中是否存在符合方法字段描述符的方法和名称、符号引用中类、字段、方法的访问性等等**

##### Preparation 准备

1. 该阶段是正式为类中定义的变量（**注意是静态变量，实例变量会在对象初始化过程中分配到堆上**）分配内存并设置类的初始值（一般都会设置为0值），概念上讲，这些变量应该分配到方法区。但是实现上各不相同。

##### Resolution 解析

1. 解析阶段是JVM讲常量池中的符号引用替换成直接引用的过程
2. 符号引用（Symbolic References）：符号引用以一组符号来描述索引的目标。可以是任何形式的字面量，指向的目标不一定已经加载到JVM内存中，与JVM实现的内存无关。
3. 直接引用（Direct References）：直接引用是可以直接指向目标的指针、偏移量或者是一个能间接定位到目标的句柄。与JVM实现的内存布局直接相关。
4. 解析动作主要针对类或接口、字段、方法、接口方法、方法类型、方法句柄和调用点限定符
5. **类或接口的解析步骤**（当前处于类D，要将一个未解析的符号引用N解析未直接引用C）：1> 要解析的C不是一个数组，则JVM将代表N的全限定名传递给D的类加载器去加载这个C。加载过程中会触发其他类的加载动作，出现异常则加载失败；2> 如果C是一个数组类型，且数组元素为对象类型，则N描述符为类似“[Ljava/lang/Integer“的形式，然后根据第一条规则加载数组元素类型，并生成一个代表数组维度和元素的数组对象；3> 如果以上均无异常，则C在JVM中已经是一个有效类或接口了，但是还需要在验证一个权限
6. **字段解析步骤**：要解析一个未被解析过的字段符号引用，首先会对字段表index所指向的类的符号引用做解析，如果类解析出现异常，则解析失败。如果解析成功，而这个字段所属类或接口用C表示，则按如下步骤进行搜索：1> 如果C本身包好了简单名称和字段描述符与目标匹配，则查找结束； 2> 否则，如果C实现了接口，则会按照继承关系从下往上递归查找匹配字段，并返回直接引用；3> 否则，会从下往上查找继承关系匹配字段，并返回直接引用；4> 否则，查找失败，抛出java.lang.NoSuchFieldError异常
7. **方法解析**，步骤与字段解析类似，详见（《深入理解Java虚拟机》）
8. **接口方法解析**，同上

##### Initiation 初始化

1. 该阶段是类加载过程的最后一个步骤，JVM开始真正的执行类中编写的Java程序代码
2. 初始化阶段就是执行类构造器<clinit>()方法，这个方法是javac编译的自动生成物
3. <clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的
4. <clinit>()不会显式的调用父类构造器，JVM会保证子类<clinit>()方法调用前，父类方法已经执行完毕
5. <clinit>()父类方法先执行，意味着父类的静态代码块要先于子类的赋值操作
6. 其余见《深入理解Java虚拟机》

### 类加载器

##### 类和类加载器

1. JVM设计团队有意将“通过一个类全限定名来获取该类的二进制字节流“的动作放到JVM外部去实现，从而让应用程序自己决定如何获取所需类。实现这个动作的代码就被称为“类加载器”Class Loader。
2. 任意一个类，必须有加载它的类加载器和这个类本身一起确立其在JVM中的唯一性。也就是说，即使是同一个类，在同一个JVM加载，但是使用了不同的Class Loader，那么这两个类也是不相等的
3. 这里的“相等”，包括代表类的Class对象的equal()方法，isAssignableFrom()方法，isInstance()方法，也包括 instanceOf

##### 双亲委派模型

1. 在JVM的角度来看，只存在两种不同的类加载器，一种是Bootstrap ClassLoader（启动类加载器）由C++实现，是JVM的一部分；一种是其他的类加载器，由Java实现，在JVM外部，他们全部继承自java.lang.ClassLoader
2. 而在Java开发人员角度，类加载器一般分为三层类加载器、双亲委派的类加载架构
3. **1. 启动类加载器（Bootstrap ClassLoader）**：用于加载<JAVA_HOME>\lib目录下的能够被JVM识别的类库
4. **2. 拓展类加载器（Extension ClassLoader）**：用于加载<JAVA_HOME>\lib\ext目录下的类库，用来实现JAVA系统类库的拓展
5. **3. 应用程序类加载器（Application ClassLoader）**：使用getSystemClassLoader()方法可以拿到，也被称为“系统类加载器”，负载加载ClassPath路径下的所有类库。如果程序中没有自定义过类加载器，这个一般是默认的类加载器
6. 通常类加载的过程由这三种类加载器互相配合完成，用户也可以添加自定义的类加载器，过程如下图
7. 双亲委派模型：各类加载器存在着层次关系，并配合工作的模型，即为双亲委派模型。该模型要求，除了Bootstrap ClassLoader即顶层的启动类加载器外，其余类均有自己的父类加载器。但是他们不是继承关系，而是组合关系复用父类加载的代码。
8. 双亲委派模型的工作过程为：如果一个类加载器收到一个类加载的请求，那么会把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，最终都会送到最顶层的类加载器去完成，如果父类加载器无法完成加载时，则由子加载器完成加载。
9. 这种模型会让Java中的类跟随类加载器一起具备类优先级的层次关系。保证都是同一个类。

![class_loader](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/class_loader.jpg)

### 虚拟机字节码执行引擎

### 运行时栈帧结构

1. JVM以方法为最基本的执行单元，“栈帧（Stack Frame）”则是用于支持JVM进行方法调用和方法执行的背后的数据结构，同时也是JVM运行时数据区中虚拟机栈的栈元素。栈帧中存储了本地变量表、操作数栈、动态连接和方法返回地址等信息。
2. 栈帧中的内存分配多少内存，在编译时就已经决定了
3. 以Java程序的视角看，在同一时刻、同一个线程内，所有调用堆栈中的方法都是运行状态，而对于执行引擎来说，栈顶的栈帧才是生效的，称为Current Stack Frame。总体结构如下图

![stack_frame](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/concept_of_stack_frame.jpg)

##### 局部变量表

1. 局部变量表：用于存储方法中的参数和局部变量。容量单位以变量槽（variable slot）来表示，一个Variable Slot一般是32位大小，可以处理器、操作系统等变化。
2. 使用索引的方式访问，从0开始至最大的变量槽数。如N代表第N个变量槽
3. 调用实例方法时，第0个槽存放的是传递方法所属对象实例的引用，可以用this访问到

##### 操作数栈

1. 操作数栈（Operand Stack）：后进先出的结构。在方法执行中，各种字节码指令往操作数栈写入和提取内容。如iadd会将栈顶两个元素出栈相加，再将结果入栈。

##### 动态链接

1. 每个栈栈都包含一个指向运行时常量池中该栈帧所属方法的引用，为了调用过程中的动态链接

##### 方法返回地址

1. 方法退出方式有两种：1. 正常调用完成，遇到返回的字节码指令，则正常将返回值传递给上层的方法调用者；2. 遇到异常而且异常没有得到妥善处理，则不会给上层调用者提供返回值
2. 方法退出过程实际等同于当前栈帧出栈，可能的操作有：恢复上层局部变量表、操作数栈，将返回值压入到调用者栈帧的操作数栈，恢复PC的值等。

### 方法调用

1. 方法调用并不等同于方法中的代码被执行，其唯一任务就是确定被调用方法的版本。
2. 由于一切方法在Class中都是符号引用，而不是实际的内存布局，因此某些调用需要在加载期甚至运行期才能确定目标的直接引用

##### 解析 Resolution

1. 类加载的解析阶段，会讲一部分在常量池中的符号引用转换成直接引用，一般符合这个要求的方法有静态方法、私有方法
2. 解析调用一定是一个静态的过程，在编译期间就完全确定，在类加载解析阶段就将符号引用全部转化为直接引用

##### 分派 Dispatch

1. 分派又分为：静态分派、动态分派。也可分为：单分派、多分派
2. 其余见《深入理解Java虚拟机》

### 基于栈的字节码解释执行引擎

1. 一般来讲JVM执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（即时编译器生成本地代码）两种选择。

##### 解释执行

##### 基于栈的指令集于基于寄存器的指令集

1. 基于栈的指令集一般都是0地址指令，依赖操作数栈进行工作；而基于寄存器的指令集比如x86架构的指令集，一般都是带操作数地址的。
2. 基于栈的指令集优势是拓展性强，但是执行速度相对较慢

##### 基于栈的解释器执行过程

1. 执行过程会伴随着频繁的操作数出栈和入栈的过程
2. 具体过程见《深入理解Java虚拟机》

### Java内存模型与线程

> 并发处理的广泛引用是Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因。

##### 一致性问题

1. 高效并发一般会涉及到数据一致性的问题，比如多个处理器都有自己的高速缓存，他们会共享内存区域，所以需要缓存一致性协议，来保证数据的一致性

![cache](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/cache_consistance.jpg)

##### Java内存模型

1. Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注JVM从内存中取出变量值和将变量值存到内存的底层细节
2. Java内存模型规定，所有的变量都存储在主内存（属于虚拟机的一部分），每条线程都有自己的工作内存，工作内存中保存了呗线程使用的变量的主内存副本，线程对变量的所有操作必须在工作内存中完成，而且不能直接读写主内存中的数据；不同线程之间也不能互相访问工作内存，线程间的数据传递必须通过主存来完成。

![java_memory_model](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/java_memory_model.jpg)

##### 内存间交互操作

1. 主存和工作内存之间的具体协议，即如何将一个变量从主存和工作内存之间同步。Java内存模型规定了8中原子操作来完成：lock、unlock、read、load、use、assign、store、write。具体含义和规定，见《深入理解Java虚拟机》

##### volatile型变量

1. volatile可以说是JVM中最轻量级的同步机制，但不容易被正确完整、完整的理解
2. volatile的作用主要有两点：第一是保证变量对所有线程的可见性，表现为如果其中一个线程修改了某个变量的值，其他线程是立即可以得知的。而普通变量只有在写会内存完成后，新值才会对其他线程可见；第二是禁止指令重排优化
3. Java内存模型中对volatile关键字的特殊定义：1.每次在使用变量时，必须先从内存中刷新最新值；2. 每次修改变量后，必须立即同步到内存；3. volatile修改的变量不会进行指令重拍

##### 原子性、可见性和有序性

1. 原子性：直接保证原子性的操作有read、write、load、assign、use、store，更大范围的原子性需要通过lock和unlock保证
2. 可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。volatile变量可以保证这一点。synchronized、final也能实现这一点。
3. 有序性：volatile和synchronized都能保证线程操作的有序性

### Java与线程

##### 线程的实现

1. 实现方式主要有三种：1. 内核线程实现（1:1）；2. 用户线程实现（1:N）；3. 混合实现（N：M）
2. 内核线程：每一个用户线程都会映射到一个内核线程上，由操作系统对线程进行统一管理。
3. 用户线程：这种线程是完全建立在用户空间上实现的，线程的各种状态的切换也都是在用户空间进行的，不需要切换到内核态。
4. 混合实现：内核线程和用户线程为N：M的关系，N<M。
5. Java线程的实现：一般主流的虚拟机是采用的内核线程的实现方案

##### Java线程调度

1. 调度方式有2中：协同式线程调度和抢占式线程调度
2. 协同式线程调度是当线程自身任务完成以后，才通知让出CPU，即切换线程，不会有线程同步问题
3. 抢占式线程调用是每个线程的的运行时间，由操作系统来统一分配。

##### 状态切换

1. Java语言定义了6种线程状态：New新建、Runnable运行、Waiting无限期等待、Timed Waiting限期等待、Blocked阻塞、Terminated结束
2. 各状态转换，见《深入理解Java虚拟机》

##### 协程

1. 协程可以理解为在用户空间实现的多线程，在切换的时候不需要进行从用户态到内核态的转变

### 线程安全与锁优化

##### 线程安全

1. 当多个线程访问一个对象时，如果不需要考虑多线程环境下的线程调度和交替执行，也不需要进行额外同步，就能得到正确的结果，那么就称其为线程安全的

##### Java语言中的线程安全

1. 我们可以将Java中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立
2. 不可变：一定是线程安全的，不需要进行任何线程安全保障措施。如final修饰的基本数据类型。
3. 绝对线程安全：例如vector使用不当还是会有线程安全的问题，比如一个线程add，一个线程remove，另一个线程get，那么可能数组越界，所以需要在执行时也需要synchronized关键字保证同步。
4. 相对线程安全：通常意义上的线程安全，比如Vector、Hashtable等
5. 线程兼容：指本身不是线程安全的，需要调用时正确的使用同步手段。比如ArrayList、HashMap
6. 线程对立：无论是否采用了同步措施，都无法保证多线程环境下的并发。应该避免。

##### 线程安全的实现

1. 互斥同步：常见的最主要的保证并发正确性的手段。互斥量（Mutex）和信号量（Semaphore）是常见的互斥实现方式。
2. Java中最基本的互斥同步手段就是synchronized。synchronized关键字经过Javac编译后，会在同步块的前后分别生成monitorenter和monitorexit两个字节码指令。如果明确了对象参数，则以这个对象引用作为reference类型来指明锁定和解锁的对象。如果未指明对象，则根据synchronized修饰的方法，取代码所在对象或者类型对象的Class对象
3. 在执行monitorenter时，先尝试获取对象锁，如果对象没有被锁定，或者当前线程已经持有了对象的锁，则锁计数器+1，monitorexit指令时，锁计数器-1，计数器为0时释放。如果获取锁对象失败，则阻塞等待。
4. 持有锁是一个重量级的操作，会涉及到用户态到内核态的切换等等
5. ReentrantLock与Synchronized类似，但是增加了一些功能：等待可中断、公平锁、锁绑定多个条件
6. 等待可中断：当持有锁的线程长时间不释放锁的时候，等待的线程可以选择放弃等待，执行其他事情；
7. 公平锁：多个线程等待同一个锁时，必须按照申请时间顺序依次获得锁。Synchronized是非公平锁，也就是任何一个等待锁的线程都可能获得锁。ReentrantLock默认也是非公平锁，但是可以通过参数设置
8. 锁绑定多个事件：一个ReentrantLock对象可以绑定多个Condition对象
9. 互斥同步属于悲观的并发策略。
10. 乐观并发策略，不管风险，先进行操作，如果没有其他线程争用共享数据，则操作成功。如果出现冲突，则一直尝试，直到没有竞争的共享数据为止，这个策略称为非阻塞同步。
11. 保证这种原子性的硬件指令通常有：Test-and—Set、Fetch-and-Increment、Swap、Compare-and-Swap（CAS）、Load-Linked
12. CAS操作：CAS指令有三个操作数，一个是内存地址V，旧的预期值A和准备的新值B。只有当V跟A符合时，才去用B更新V，否则就不更新。比如Java内存模型中，两个线程A和B都读入了主存中的变量i=25，并且两个线程都要去更改i的值，那么假如A更改为了26并将其写会主存，则B要更新时，则进行CAS操作，比对自身工作内存中i的副本和主存中的i是否一致，不一致，则不更新
13. 无同步解决方案：可重入代码和Thread Local

### 锁优化

##### 自旋锁和自适应锁

1. 在互斥同步中，最大的影响就是阻塞，因为会涉及到线程的挂起和恢复都需要转入到内核态完成，而这些操作开销是很大的，而很多共享数据的操作往往只需要一小段时间。所以我们可以让请求锁的线程“稍等一会儿”，不放弃处理机的执行时间，只需让线程陷入一个忙等状态即可
2. 自旋锁对于占用锁比较短的情况，效果非常好，如果一个线程占用锁时间很长，则需要在超过自旋次数后，用传统方式挂起。
3. 自适应锁就是根据前一次在同一个锁上的自旋时间和拥有者状态，决定是否启用自旋

##### 锁粗化

1. 通常我们会尽量将锁范围限制到最小，但是如果一些列操作都需要给同一个对象反复加锁，则需要扩大锁的范围

##### 轻量级锁

1. 相对于传统的重量级锁来说的，为了减少传统重量级锁使用操作系统互斥量产生的性能消耗。引入了轻量级锁。
2. 轻量级锁工作过程：代码进入同步快的时候，如果此同步对象没有被锁定，则JVM首先会在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word拷贝.然后JVM将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针，如果操作成功了，则代表拥有了这个对象的锁，并将标记位更新为“00”，表示为轻量级锁状态。如果更新失败了，则查看是否当前的对象的Mark Word是否指向当前线程的栈帧，如果拥有则直接进入。如果两个以上的线程争用同一个锁，则膨胀为重量级锁
3. 解锁过程：通过CAS操作把对象的Mark Word和线程中复制的Displaced Mark Word替换回来，如果成功，则顺利完成。如果失败，则证明有其他线程尝试过该锁，则需要做唤醒操作

![mark_word](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/mark_word.jpg)

![CAS](https://github.com/ToTheMoonLee/Blog/blob/main/JVM/illustration/CAS.jpg)

##### 偏向锁

1. 偏向锁的引入目的是为了消除无竞争情况下的同步原语。连CAS都不做了。
2. 如果接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步
3. 如果启用了偏心锁，则第一次获得锁对象后，JVM会将对象头中的标志设置为“01”，偏心模式设置为“1”，同时使用CAS将线程ID记录在对象的Mark Word中。如果CAS成功，则之后该进程再次进入的时候，则不需要进行同步操作
4. 一点另一个进程尝试获取这个锁的情况，则偏心模式立刻宣告结束。根据是否被锁定状态，撤销为未锁定或轻量级锁定状态。


