## 数据结构

### 一、绪论

##### 数据结构的基本概念

思维导图



重点：时间复杂度、空间复杂度分析

数据结构三要素：逻辑结构、存储结构、数据的运算

逻辑结构：

1. 线性结构：线性表、队列、栈
2. 非线性结构：树、图、集合

存储结构（物理结构）：数据元素的表示和关系的表示

1. 顺序存储：数组；支持随机存储；增删不容易
2. 链式存储：链表；不支持随机存储；增删简单
3. 索引存储：建立索引表；检索速度快；索引表会占用额外内存
4. 散列存储（Hash）：根据关键字直接计算存储位置；增删查速度都快；可能出现冲突

数据的运算：运算的定义是逻辑结构层次的；实现是存储结构层次的



**P3 习题 4 7**



##### 算法和算法评价

思维导图



特性：有穷、确定、可行、输入、输出

算法时间复杂度：依赖于规模N，也取决于初始状态

![时间复杂度分析](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/时间复杂度分析.jpg)

空间复杂度



**P7 习题 1 12**



### 二、线性表

重点：算法题；掌握各种基本操作（基于顺序存储和链式存储）；算法最重要的是思想

##### 线性表的定义和基本操作

思维导图



##### 线性表的顺序表示

思维导图



顺序存储（顺序表）：随机存储；



**P17 综合题 所有（一定好好看看）**



##### 线性表的链式表示

思维导图



链式存储（单链表）：带头节点、不带头节点

1. 头插法：在头部插入
2. 位插法：在尾部插入
3. 按序号查找
4. 按值查找
5. 在第i个位置插入结点：后插，在i之后插入；前插，在i之前插入（也可以现在i后插，然后交换两个结点的值）
6. 删除节点
7. 求表长

双链表：

1. 插入操作：先连后断，可以画图
2. 删除操作：画图即可看出

循环单链表：

1. 任何位置都能开始遍历，如果经常使用表头和表尾，则可使用尾指针

循环双链表：

1. h.prior = r r.next = h

静态链表：

1. 借助数组来描述线性表的链式存储结构
2. 指针是数组下标



**P36 习题 4 7 20 综合题 全部（算法题，一定好好看看，拿下）**



### 三、栈和队列

重点：栈序列合法性、队列操作及其特征；算法设计题；双端队列；特殊矩阵压缩存储



##### 栈

思维导图



栈的基本操作：InitStack(&S); StackEmpty(S);Push(&S,x);Pop(&S,&x);GetTop(&S,&x);DestroyStack(&S)

顺序存储实现（顺序栈）：

1. 栈顶指针可以指向栈顶元素（初始状态top=-1），也可以指向将要入栈的位置（初始状态top=0）
2. 共享栈：如果指向栈顶元素（初始状态top1=-1；top2=max）

链式存储实现：使用头插法即可，带头节点和不带头节点两种实现



**P66 综合题**



##### 队列

思维导图



队列基本操作：InitQueue(&Q);QueueEmpty(Q);EnQueue(&Q,x);DeQueue(&Q,&x);GetHead(Q,&x)

顺序存储实现：使用front指针跟rear指针分别指向数组的开始和结尾，注意真正指向的位置区别

循环队列：

1. 初始化：front=rear=0
2. 出队：front=（front+1）%maxSize
3. 入队：rear=（rear+1）%maxSize
4. 队列长度：（rear+maxSize-front）%maxSize
5. 队列满的三种处理方式：
   1. 牺牲一个元素：队空：front=rear=0；队满：（rear+1）%maxSize=front
   2. 增设size记录总个数
   3. 增设tag区分

链式存储实现队列：使用头指针和尾指针，分别指向第一个元素和最后一个元素；最好使用带头节点的方式实现，避免处理空队列情况

双端队列：

1. 两端都可输入输出
2. 输入受限：只允许一端输入
3. 输出受限：只允许一端输出



**P78 习题 14 16 17 综合题全部**



##### 栈和队列的应用

思维导图



栈应用

1. 括号匹配
2. 表达式求值：中缀转后缀，后缀表达式求值，表达式树（后缀表达式与表达式树的后根遍历一致）
3. 递归中的应用：借助栈实现（可以画出递归树看下执行过程）

队列应用

1. 二叉树层序遍历
2. 图的广度优先遍历
3. 计算机操作系统中，排队



**P90 综合题全部**



##### 特殊矩阵的压缩存储

思维导图



使用一维数组存储二维数组，先行后列和先列后行

对称矩阵：以主对角线为对称轴，分为上三角区、主对角线区、下三角区（现场推导公式即可）

三角矩阵：多一个常量存储

三对角矩阵：现场推导计算

稀疏矩阵：使用三元组存储法（行，列，数值）、十字链表法



### 四、串

重点：字符串模式匹配、KMP匹配算法原理、next数组的推理和使用



##### 串的定义和实现

思维导图



子串在主串中的位置：子串的第一个字符在主串中的位置

存储方式：

1. 定长顺序存储表示：初始分配一段固定的存储单元来存储字符串，使用length记录长度或在最后一个位置'\0'表示
2. 堆分配存储表示：可以动态改变分配的存储空间

模式匹配：子串在主串中的位置

KMP算法，通过子串来构建next数组，然后利用next数组来进行匹配滑动



### 五、树与二叉树

重点：树和二叉树性质、遍历、转换、存储结构、操作特性、满二叉树、完全二叉树、线索二叉树、哈夫曼树、二叉平衡树、树和森林转换



##### 树的基本概念

思维导图



树的度：结点最大的度为树的度

树的高度：树中最大的层数

树的路径和长度：自上而下从一个祖先结点到子孙节点经过的路径，就是这两个结点之间的路径；经过边的个数就是路径的长度

森林：m颗互不相交的树

**树的性质**：

![树的基本性质](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/树的基本性质.jpg)

习题7的计算 n=n0+n1+n2+n3+n4 = 10x1 + 1x2 + 10x3 + 20x4 + 1   n1+n2+n3+n4 = 10 + 1 + 10 + 20 从而求出n0

**P120 习题 3 4 7**



##### 二叉树

思维导图



满二叉树：

1. 有2^h-1个结点；即每层含有最多的孩子数
2. 若根结点编号为1，按层编号，则根结点为i时，左孩子编号为2i，右孩子为2i+1；根结点为i/2

完全二叉树：

1. i<= n/2，则为分支结点；否则则为叶子结点
2. 叶子结点只可能出现在最大两层上，且最后一层集中在左侧
3. 若有度为1的结点，则该结点只有一个且只有左孩子
4. 若出现编号为i的结点只有左孩子，则大于i的结点全部都是叶子结点
5. n为奇数，则均有左右孩子；n为偶数，则编号最大的分支结点，只有左孩子

二叉排序树：

平衡二叉树：左子树与右子树高度相差不超过1

二叉树性质：

1. 非空二叉树，叶子结点数=度为2的结点数+1
2. 第k层之多有2^(k-1)-1个结点
3. 高为h的二叉树之多有2^h-1个结点
4. 对完全二叉树编号，从1到n，i/2为双亲；2i为左孩子，2i+1为右孩子；i所在层次为log2i +1 （log2i向下取整）
5. n个结点完全二叉树高度

![二叉树性质](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/二叉树性质.jpg)

存储方式：

1. 顺序存储：完全二叉树，满二叉树，使用顺序存储可以反应其结构；存储普通二叉树时，会影响浪费空间
2. 链式存储：n个结点的二叉树中，有n+1个空链域



**习题 1 5 6 7 11 19 20 23 综合题全部**  



##### 二叉树的遍历

思维导图



遍历： 先序、中序、后序、层序

先序和中序可以确定一棵唯一的二叉树；后序和中序可以确定一棵唯一的二叉树

线索二叉树：无左孩子，则左指针指向直接前驱；无右孩子，则右指针指向直接后继；结构（lchild,ltag,data,rtag,rchild)

中序线索二叉树的创建、使用：P136

前序线索二叉树、后序线索二叉树



**P139 习题 5 23 29 30 35 综合题全部**



##### 树和森林

思维导图



树的存储结构：

1. 双亲表示法
2. 孩子兄弟表示法

![双亲表示法](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/双亲表示法.jpg)



![孩子兄弟表示法](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/孩子兄弟表示法.jpg)



树、森林、二叉树转换：

树转换二叉树：左孩子，右兄弟；本质上就是孩子兄弟表示法

森林转换二叉树：将每颗树转换为孩子兄弟表示法，然后将每颗树依次链接到右边

![森林转二叉树](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/森林转二叉树.jpg)



树和森林遍历：



![树森林遍历](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/树森林遍历.jpg)



**P165 习题 2 7 8 综合题全部**



##### 树与二叉树的应用

思维导图



BST（二叉排序树）：增删改查

BST查找性能：最坏o(n)，最好是平衡二叉树o(log2 n)

平衡二叉树：左右子树高度相差不超过1；平衡因子，左右两颗树的差，只可能为-1、0、1

二叉树调整：LL、RR、LR、RL旋转

哈夫曼树：构造；哈夫曼编码

![平衡二叉树递推公式](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/平衡二叉树递推公式.jpg)



**P181 习题 4 13 14 20 22 24 27 29 33 综合题所有**



### 六、图

##### 图的基本概念

思维导图



**P201 习题全部**



##### 图的存储及基本操作

思维导图



邻接矩阵：

![邻接矩阵](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/邻接矩阵.jpg)

邻接表：

![邻接表](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/邻接表.jpg)



**P210 习题 2 7**



##### 图的遍历

思维导图



##### 图的应用

思维导图



**最小生成树、最短路径、拓扑排序、关键路径**

**最小生成树**：Prim算法

![Prim算法](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/Prim算法.jpg)

![Prim算法2](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/Prim算法2.jpg)



Kruskal（克鲁斯卡尔）算法：

![Kruskal算法](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/Kruskal算法.jpg)

**最短路径**：

单源最短路径： 

1. BFS算法（无权图）：广度优先遍历，修改每一层的距离数
2. Dijkstra（迪杰斯特拉）（带权图、无权图）（贪心算法）：O(v^2)
   1. boolean 类型 final[5] ：首次初始化0为true，剩余的为false；表示当前结点是否已经找到最短路径
   2.  int 类型 dist[5]  ：从0经过已经找到最短路径的结点，能到达的最短路径
   3. int类型path[5] 初始化final：0到各端点的路径

​	找到在final数组中标记为false的顶点，并从dist数组中找到距离最小的点，加入到path中；循环此操作

各顶点间最短路径：

Floyd（弗洛伊德）（动态规划思想）：

1. 使用两个邻接矩阵（二维的） A 和 path；A用来存储各个点的距离，path用来存储从i到j需要的中转点
2. 初始化时，为不添加中转点的状态
3. 之后依次允许 0中转，0到1中转，以此类推，并比对经过中转点之后，是否有小于邻接矩阵A中的最短路径并更新
4. 直到最后一个中转点添加后，则得到最终矩阵

有向无环图：合并表达式

![有向无环图](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/有向无环图.jpg)



拓扑排序：



关键路径：

1. 事件最早发生时间
2. 事件最晚发生时间
3. 做差为0的路径上，就是关键路径



**P236 8 10 14 17 18 19 22 综合题全部**



### 七、查找

散列表相关冲突解决，查找次数；折半查找判定树；B树和B+树

##### 查找的基本概念

思维导图



平均查找长度

有序顺序查找判定树：

![顺序查找判定树](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/顺序查找判定树.jpg)



二分查找判定树：

![二分查找判定树](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/二分查找判定树.jpg)



**P262 习题 9 15 18 19 综合题全部**



##### B树和B+树

思维导图



B树性质：

![B树性质](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/B树性质.jpg)



B树的插入，可能导致需要分裂，向上合并：

![B树的插入](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/B树的插入.jpg)



B树删除：

![B树的删除](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/B树的删除.jpg)





B+树性质与B树的区别：

![B+树性质和B树的区别](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/B+树性质和B树的区别.jpg)



**P275 习题全部**



##### 散列表

思维导图



冲突解决方法：

1. 开放定址法
   1. 线性探测法： 删除元素时，不能实际删除，只是做个标记
   2. 平方探测法：
   3. 再散列法：
   4. 伪随机
2. 拉链法

性能分析：

![散列表性能分析](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/散列表性能分析.jpg)



**P284 习题 4 5 18 综合题全部**



### 八、排序

##### 排序的基本概念

思维导图



算法稳定性

内部排序：在内存排序； 外部排序：在内存和外存之间移动

大分类：

1. 插入排序
2. 交换排序
3. 选择排序
4. 归并排序
5. 基排序



##### 插入排序

思维导图



直接插入排序：稳定

![直接插入排序](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/直接插入排序.jpg)



折半插入排序：前面排序的位置使用折半查找确定位置

希尔排序：不稳定

![希尔排序](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/希尔排序.jpg)



##### 交换排序

思维导图



冒泡排序：稳定、每趟元素都会放到最终位置上

![冒泡排序](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/冒泡排序.jpg)



快速排序：不稳定

![快速排序](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/快速排序.jpg)



##### 选择排序

思维导图



简单选择排序：不稳定

![简单选择排序](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/简单选择排序.jpg)



堆排序：不稳定

![建堆-1](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/建堆-1.jpg)



![堆排序-2](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/堆排序-2.jpg)



##### 归并排序和基数排序

思维导图



归并排序：稳定

![归并排序](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/归并排序.png)



基数排序：稳定



![基排序](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/基排序.png)



##### 内部排序和应用

思维导图



![算法比较](/Users/lixiangyue/Personal/blog/Blog/foundation/数据结构/images/算法比较.png)



##### 外部排序

思维导图



外部排序：

增大归并路数可以减少磁盘I/O次数

减少初始归并段数可以减少磁盘I/O

























